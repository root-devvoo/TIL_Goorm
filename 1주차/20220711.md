# 구름 쿠버네티스 과정 5기 1일차_20220711

## DevOps란?

개발과 운영을 같이 하겠다는 의미

- 방법론 중 하나
- 실무에서는 서버 구축과 운영을 함께 한다는 의미도 내포
- 서버
  - 웹 서버
  - 데이터베이스 서버
  - DNS 서버 등등...

## 네트워크

- 통신을 위해 사용

<img src="https://user-images.githubusercontent.com/78403443/178176039-41bf9ff2-ef09-4d8f-9068-3e7f4bd80f0b.png" alt="image" style="zoom:50%;" />

### 네트워크 망

- 통신으로 연결되어 있는 복합 망

### 네트워크 구조

- 네트워크 엣지

  > 네트워크 끝과 끝에 위치해있는 것 = 네트워크 엣지

  - 랩탑, 데스크탑, 웹 서버 등이 위치

- 네트워크 코어

  > 네트워크 중앙 = 네트워크 코어

  - 라우터가 위치

    > 구글을 접속하기 위해서는 라우터를 거친다.

    - 통신을 할 수 있도록 다리 역할을 해주는 장치

- 링크

  > 선 = 링크

  - 통신 장비를 연결해주는 선

    > LAN선도 링크라고 할 수 있다.

### 인터넷에서 제공해주는 통신 서비스

- TCP

  - 신뢰성있는 통신 제공

    - 도착지까지 잘 전달되었는지 확인

  - 네트워크 상황 고려

  - UDP에 비해 속도가 느림

  - 우편에서 등기와 비슷

    > 도착 서명까지 받음

    - 비용이 듦
      - ex) 컴퓨터 자원, 네트워크 자원

- UDP

  - 비신뢰성 통신 제공
    - 도착지까지 잘 전달되었는지 확인 X
  - 네트워크 상황 고려 X
  - TCP에 비해 속도가 빠름
  - 우편에서 편지와 비슷
    - 비용이 저렴
  - 전화 / 실시간 VOD에서 주로 사용

### 프로토콜이란?

- 통신 규약
  - ex) 전화를 하면서 바로 본론을 얘기하는 것이 아닌 간단한 인사를 주고 받은 후 이야기를 꺼내는 것과 비슷
  - 실제 메시지를 주고 받기 전 준비 동작
  - 같은 프로토콜이어야 통신 가능

### OSI 7계층 / TCP 5계층

- OSI 7계층

  ![OSI7](https://user-images.githubusercontent.com/78403443/178178160-41a92d06-c71e-4e37-832b-279e34eb123e.png)

  > 모든 층이 상대방과 약속이 되어있어야 통신 가능 

  - 애플리케이션
  - 프레젠테이션
  - 세션
  - 트랜스포트
  - 네트워크
  - 데이터링크
  - 물리

> 이 7계층을 적게 나눠놓은 것이 TCP 5계층

- TCP 5계층 (이걸로 학습)
  - 통신 계층을 5개로 나눠놓은 것
    - 애플리케이션
    - 트랜스포트 (OSI 7계층의 프레젠테이션, 세션, 트랜스포트 계층을 하나로 합침)
    - 네트워크
    - 데이터링크
    - 물리

> 계층이란 것은 개념적으로 나눠놓은 것 (사용자의 몫임, 그저 약속일 뿐)

#### 애플리케이션 계층

- 실제로 프로그램이 동작하는 계층
  - 사용자는 브라우저, 서버는 웹 서버

##### 클라이언트 - 서버 모델

- 서버는 웹 서버, 클라이언트는 웹 브라우저라고 생각하면 됨

  - 서버는 24시간 동작해야 함 / 고정된 아이피를 가지고 있어야 함

    ```
    Windows 명령 프롬프트 
    nslookup www.google.com 입력
    
    ############ 결과 값 #############
    (중략)
    권한 없는 응답:
    이름:    www.google.com
    Addresses:  2404:6800:400a:80e::2004
              142.250.76.132
    ```

    > 우리는 www.google.com 을 접속하는거지만, 실제 142.250.76.132 라는 IP를 가지고 있는 구글의 웹 서버에 접속하는 것임
    >
    > 그래서 142.250.76.132 주소를 브라우저에서 똑같이 접속하면 구글 홈페이지 접속

    - 아이피 주소 : 고유한 주소
    - 서버가 고정된 아이피 주소를 가지고 있어야 클라이언트에서 찾아갈 수 있음

##### 소켓

- 애플리케이션 계층과 트랜스포트 계층 간의 통신시 필요한 항목

- IP주소와 포트가 필요

  - 포트는 특정 프로세스를 지정할 때 필요한 항목

    > 위에는 숨겨져 있지만, 원래 142.250.76.132:80 이라고 포트 번호가 정의되있음

    - ex) 142.250.76.132:80을 브라우저 url 입력란에 입력하고 엔터
    - 포트는 이해하기 쉽게 통로라고 생각하기(ex. 80번 통로)

##### 애플리케이션 계층에서 트랜스포트 계층에게 원하는 사항

1. data integrity
   - 내가 원하는 데이터가 유실되지 않고 온전하게 목적지까지 도달하면 좋겠다는 사항
2. timing
   - 내가 보내는 데이터가 원하는 시간 내에 도착하면 좋겠다는 사항
3. throughput
   - 내가 보내는 데이터가 적절한 용량으로 전달됐으면 좋겠다는 사항
4. security
   - 내가 보내는 데이터가 안전하면 좋겠다는 사항

> 트랜스포트 계층에서는 이 중에서 1번 사항만 지켜줌
>
> - TCP는 제공해주지만 UDP는 해당 사항 마저도 지켜주지 못함

##### 애플리케이션 계층에서 가장 많이 사용하는 서비스와 프로토콜

- Web and HTTP

###### HTTP

- HyperText Transfer Protocol
- 하이퍼텍스트 전달 프로토콜
- 웹 브라우저에서 웹 서버로 접근할 때 서버에서 클라이언트로 텍스트를 전달해주는 것
  - HTTP request
    - 클라이언트에서 원하는 하이퍼텍스트 파일 이름 요청
  - HTTP response
    - 응답하여 디스크를 읽고 파일 전송
- TCP 기반
- stateless
  - 요청이 들어오면 응답으로 파일을 보내주고 다른 요청 처리

##### 소켓이란?

- 운영체제에서 제공해주는 API의 일종

##### 소켓 통신이란?

- 애플리케이션 프로세스들끼리의 통신
  - 프로세스란? 동작하고 있는 프로그램

###### 소켓 통신을 하기 위해서 IP주소와 포트 번호 필요

- 추가적으로 TCP / UDP 프로토콜 지정도 필요

###### 소켓 통신을 위해서 소켓을 만들 때

- TCP 통신을 하고 싶다면 TCP 소켓 생성
- UDP 통신을 하고 싶다면 UDP 소켓 생성

###### TCP 소켓 통신 방법

![TCP_소켓_통신_1](https://user-images.githubusercontent.com/78403443/178184193-afecbcda-2cfa-4de3-85b7-4f8f9e08d222.png)

![TCP_소켓_통신_2](https://user-images.githubusercontent.com/78403443/178184198-535c7f35-2520-459b-a8e0-da6f7efdc0c0.png)

> TCP 소켓 통신 방법은 그림을 참조

#### 트랜스포트 계층

- 전송 계층
  - 전송에 관련된 부분을 담당하고 있음
  - TCP / UDP

##### 트랜스포트 계층의 기능

###### 멀티플렉싱

> 멀티플렉싱은 메시지를 애플리케이션 계층에서 받아 트랜스포트 계층에서 세그먼트로 포장하는 것

- 애플리케이션 계층에서 메시지를 생성하여 트랜스포트 계층으로 내리면 하나의 세그먼트로 만들어서 밑으로 보내는 방식

###### 디멀티플렉싱

> 포장되어있는 것을 포장 해제해서 보는 것

- 통신을 수신하는 측의 트랜스포트 계층에서 세그먼트를 받아 메시지를 필요로 하는 해당 프로세스에게 올려주는 방식

| ![세그먼트](https://user-images.githubusercontent.com/78403443/178195865-2378690e-ff0e-45a0-aad9-4886a950e928.png) |
| :----------------------------------------------------------: |
|   *세그먼트*<BR>(이건 큰 틀에서의 세그먼트를 표현한 것임)    |

> source port = 출발 포트, dest port = 도착지 포트

**세그먼트 = Header + Data**

> 세그먼트는 헤더와 데이터로 구성되어있다.

| ![UDP_디멀티플렉싱](https://user-images.githubusercontent.com/78403443/178196225-0b9cea1e-31be-470b-90f6-d39f3b5d7ad8.png) |
| :----------------------------------------------------------: |
| ***UDP 디멀티플렉싱***<BR>(여기서 IP주소는 없는 것으로 가정) |

> 멀티플렉싱과 디멀티플렉싱은 애플리케이션과 트랜스포트 계층에서 동작하는 기능이기 때문에, 트랜스포트 계층에서만 일어나는 동작

| ![TCP_디멀티플렉싱](https://user-images.githubusercontent.com/78403443/178196855-06896c28-3176-4437-9e80-c5c4ae3182f6.png) |
| :----------------------------------------------------------: |
|                    ***TCP 디멀티플렉싱***                    |

> TCP 디멀티플렉싱에서는 출발지 IP와 포트번호, 도착지 IP와 포트번호 명시
>
> 네모가 각각 다른 프로세스를 의미하긴 하지만, (목적이 같다면) 같은 포트를 공유함(그러나 어쨌든 별개의 프로세스), 서로 목적이 다르면 다른 포트 번호를 가짐(이건 당연한 얘기).

> UDP와 TCP 멀티플렉싱 & 디멀티플렉싱은 그림을 참조 (해석도 가능해야 함)

##### UDP 세그먼트

| ![UDP_세그먼트](https://user-images.githubusercontent.com/78403443/178200786-7bf43901-d5ea-4bb9-a0f4-09a16b09dae9.png) |
| :----------------------------------------------------------: |
|                        *UDP 세그먼트*                        |

- length : 데이터의 길이
- checksum : 전송 도중에 에러가 발생했는지 확인할 수 있는 필드
  - checksum의 내용이 훼손되어 있으면 수신 측에서 디멀티플렉싱을 하지 않고 drop 시킴

> UDP가 아무런 기능도 하지 않을 것 같지만 에러 체크라는 기본적인 기능은 수행해줌

- 멀티플렉싱 / 디멀티플렉싱도 해줌

##### TCP

- 애플리케이션 계층에서 내려오는 메시지를 하나도 유실되지 않고 전달해야 한다는 임무

- TCP가 유실되지 않고 데이터를 보낸다고 하더라도 하위 계층(네트워크 계층, 데이터링크 계층, 물리 계층, 링크, 라우터 등등)에서 손실이 일어나지 않을 거란 보장 X

  > 과연 TCP는 어떻게 신뢰성 있는 통신을 제공할까?

###### TCP 역할

- error가 발생했는지 판단(Error Detection)
  - checksum
- 받는 사람이 패킷을 잘 받았는지, 받지 못했는지의 의견 공유가 필요(Feedback)
  - Acknowledgement(ACKs) : 잘 받았다는 메시지
  - Negative Acknowledgement(NAKs or NACKs) : 잘 받지 못했다는 의미
- 패킷을 받을 때마다 Feedback 필요
  - ACKs / NAKs 둘다 필요
- 제대로 통신이 이뤄지지 않으면 재전송해야 함(Retransmission)

##### RDT Protocol

- 트랜스포트 계층에서 신뢰성있는 통신이 이루어지도록 하기 위한 프로토콜
- Reliable Data Transfer

###### RDT 1.0 (완벽하게 신뢰적인 통신 가정)

- no errors
- no loss (패킷 소실)
- 보내는 데이터가 문제없이 송신됨
- 받는 사람은 받아서 그대로 애플리케이션 계층에 올리면 됨

> - 비현실적인 상황
>   - 현실적인 상황을 하나씩 추가

###### RDT 2.0 (패킷 에러가 발생할 수 있는 상황 가정)

- ACKs / NAKs 사용

###### RDT 2.1

- 현재까지 본 내용은 완벽하게 보임
- error 발생시 구체적인 방안 필요

![RDT_2 1](https://user-images.githubusercontent.com/78403443/178204333-a23150a7-a9ed-4d20-88f9-4058d36a77cf.png)

시간의 흐름대로 생각해보자

1. 보내는 측에서 받는 측으로 데이터를 전송
2. 받는 측에서 에러 탐지 수행
3. 받는 측에서 응답을 하는데 error 발생 가능성 존재
   - 보낸 측에서 ACK인지 NAK인지 인지 모름
   - Feedback 패킷에도 checksum을 넣기
4. 보낸 측에서 ACK인지 NAK인지 판단이 안 될 경우 패킷을 재전송
   - 받는 측에서는 해당 패킷이 중복 패킷인지 판단할 필요가 있음
     - 패킷에 번호(sequence number) 부여
       - 같은 번호면 해당 패킷을 drop

> sequence number 어디에 넣어줄까?
>
> - 헤더에 넣음
>   - 막무가내로 지정하면 숫자가 무한대로 지정될 수 있음
>   - 헤더의 크기도 무한대가 될 수 있음
>   - 헤더의 크기는 줄이면 줄일 수록 좋음
>   - 최소한으로 사용하려면 0, 1 두 개만 존재하면 됨 (2<sup>0</sup> (2의 0제곱))
>     - 필드 크기를 1bit 사용하면 충분

![RDT_2 1_example](https://user-images.githubusercontent.com/78403443/178209169-22c092fa-1f2f-4273-a5cd-5a263e0f0939.png)

###### RDT 2.2

- NAK / NACK 없이 ACK만 사용하는 방법

> 순서
>
> 1. 보내는 측에서 PKT(0)을 보냄
>
> 2. 받는 측에서 받고 ACK(0)을 보냄
>
> 3. 보내는 측에서 PKT(1)을 보내다가 에러 발생
>
> 4. 받는 측에서 ACK(0)을 보냄
>
> 5. 보내는 측에서 PKT(1)을 보냄
>
> 6. 받는 측에서 ACK(1)을 보냄
>
> 7. 보내는 측에서 PKT(0)을 보냄
>
>    ... 반복
>
> 4번 부분의 문제 때문에 RDT 3.0이 나옴

###### RDT 3.0

- 패킷 전송 도중에 유실이 발생하여 침묵이 흐르게 됨
  - 누군가 먼저 얘기를 꺼내야 하는 상황이 옴
- 보내는 측에서 타이머 설정
  - 보내는 측에서 패킷을 보낼 때마다 보낸 후 timer가 동작
  - 타이머는 확실한 시간을 갖기 어려움
    - 타이머 시간이 짧으면 복구는 빠름, 중복된 패킷을 보낼 가능성이 존재
    - 타이머 시간이 길면 네트워크 부하 발생 가능성은 적으나, 복구가 늦음

![RDT_2 2](https://user-images.githubusercontent.com/78403443/178213802-1f734164-6cdb-43d0-bc85-c1b257e3509e.png)

RDT 3.0 에서 보내는 도중 유실된 경우, 타이머 동작

![RDT_2 2_2](https://user-images.githubusercontent.com/78403443/178213708-d38f8d23-251f-4ca6-9ad9-1c946c028f40.png)

두번째 RDT 3.0 에서는 응답 도중 유실 되었을 경우지만(그림 좌측), 타이머 동작.

위와 같이 타이머가 동작하면 타이밍 문제가 생겨도 중복될지언정 잘 보내주도록 할 수 있다.<BR>(네트워크에 대한 문제들을 하나씩 해결해 나감)

RDT 3.0은 실제로는 사용함에 불편함을 느낄 수 있음

- RDT protocol은 패킷을 하나씩 보내는 방식이기 때문에 속도도 빠르지 않고, 패킷 낭비 발생 가능성 존재

  > ACK가 오기 전까지 다른 통신을 할 수 없기 때문에

- 이에 대응하기 위해 pipelined protocol 사용

  - 대량으로 보내면 어떤 걸 먼저 처리하고 피드백은 어떤 순서로 줘야하는지 혼란스러울 수 있음
    - 그래서, pipelined protocol에서 go-Back-N, Selective Repeat 프로토콜을 추가로 사용

**Go-Back-N**

| ![go-back-N](https://user-images.githubusercontent.com/78403443/178218592-5d02ed00-30df-4d5a-9048-c79aba30b4b9.png) |
| :----------------------------------------------------------: |
|         *go-Back-N*<br>(말그대로 다시 돌아간다는 뜻)         |

> 하나 하나씩 여러 패킷을 순서대로 보낸다.
>
> 2번의 경우 보내다가 유실됨, 그리고 3번 보냄.<br>그러나, 3번을 받았지만 2번이 오지 않았기 때문에, 3번에 대한 것을 버리고, 1번에 대한 응답을 보냄.<br>그리고, 4번 5번을 보냄.. 받긴 했으나 4번, 5번도 필요가 없기 때문에 버림
>
> 타이머는 기본적으로 동작을 하는데, 타이머가 동작을 하다가 2번에 대한 timeout이 나오면, 2번으로 돌아가서 2번부터 다시 보내는 방식...
>
> 이와 같이 timeout된 상태로 돌아가서 거기서부터 다시 순차적으로 다시 보내는 방식이 'go-Back-N'이다.

- 일정한 크기만큼 패킷을 한 번에 보냄
  - 일정한 크기 (Window size)
- 보내는 패킷마다 타이머 갖고 있음
  - 타임 아웃이 되면 해당 패킷부터 마지막 패킷까지 전부 재전송

문제점

- 문제가 된 패킷 이후부터 전부 재전송함
  - Window size는 훨씬 덬 ㅡㅁ
  - 성능 문제 발생

**selective-repeat**

| ![selective-repeat](https://user-images.githubusercontent.com/78403443/178221295-dfe5c865-21cb-4423-af7d-964bc93154d3.png) |
| :----------------------------------------------------------: |
|                      *selective-repeat*                      |

> 버퍼를 이용
>
> 0번을 보내고, 0번을 받았다. 그리고 0번에 대한 응답을 보내줌.<br>그 와중에 1번이 감, 1번이 받았으면 1번에 대한 응답을 보내준다.<br>그리고 2번을 보냄... 근데, 유실됨.
>
> 그러나, go back n과 다르게 얘는 이어서 3번을 보내고, 3번을 받는다. 그리고 그것을 버퍼에 임시로 저장해놓고, 응답을 함.<br>(버퍼는 2, 3, 4, 5로 잡혀있으니 2번은 비어놓고 3, 4, 5는 받을 수 있다. 그래서 3, 4, 5는 잘 받고 응답도 함.)
>
> 만약에 그림 버퍼 처럼 2번이 타임아웃 되기 전에 6번이 오면?<br>버퍼 크기를 넘었을 때 이후 패킷을 전달받으면 해당 패킷은 버린다.<br>문제가 발생한 패킷만 다시 전송하는 방식<BR>(만약 버퍼 범위 바깥인 6번쪽 차례가 되어 보내지는데, 그때까지도 2번이 송,수신 되지 않은 상태라면, 6번은 잘 와도 버리게 되며, 2번이 들어오면 버퍼 범위를 다시 이동하여 진행함)

- 문제가 발생한 패킷만 다시 전송하는 방식
- 버퍼라는 개념
  - 버퍼는 임시 저장 공간
  - 버퍼 범위 안에서 다음 패킷이 먼저 오면 해당 패킷을 버퍼에 저장
  - 해당 패킷이 안오면 보내는 측에서 타임 아웃으로 해당 패킷을 재전송
  - 버퍼에 저장되어 있던 패킷과 재전송받은 패킷을 합쳐서 상위 계층으로 올려줌

> 시퀀스 넘버가 증가하면 버퍼의 양도 증가하는가?<br>네트워크 상황을 고려하여 버퍼의 크기도 정해짐
>
> - 버퍼의 크기도 무한정 늘릴 수 없음
> - 버퍼의 가장 적정 크기 : [Window size] * 2
>
> 윈도우는 보내는 입장의 패킷 범위를 말하고, 버퍼는 받는 입장에서 임시로 저장할 공간 범위를 말함.